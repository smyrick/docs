---
title: Server-Driven UI Basics
id: TN0032
tags: [schema-design, server-driven-ui]
---

Server-Driven UI (SDUI) is an architectural pattern that aims to reduce client-side logic and provide consistency across client platforms (web/iOS/Android/etc) by returning product infomation from an API instead of domain data. This approach is geared toward use cases where collaboration between front-end and back-end teams is possible and there is a strong desire to build a cohesive experience across multiple teams and organizations.

> For advanced patterns and schema types see [more SDUI topics](/technotes/tags/server-driven-ui).

## Architectual Goals

When building a graph with server-driven UI, itâ€™s often desirable to converge the schema with the design language being used by client teams. In practice, this requires a definitive design system and a well-defined collection of components to use on the front end to render views.

The primary need for SDUI comes from mobile native-app development. These platforms require shipping versions of your client-side app to a store that usually has a lengthy review process before a new version gets published. Then, even after a new version of the app is released, users have to update their versions from the store to start using or experiencing the new features.

Instead, if your API returned exactly what was displayed on the screen you could control when different UI elements or text are displayed. Changes can also be made to the inputs sent to the API without requiring any app updates.

## Guiding Principles

SDUI is not a framework or library you can install, but a design pattern that can be implemented and followed in many different ways while still adhering the same core principles. You may have just a few parts of the app controlled from the server, like text or if certain elements should be hidden. It could then advance to more parts like changing theming or component features from the API, all the way to having a generic layout that could render any UI component in any order.

### Start with UI Mocks

Instead of looking at data models or API responses, start with your UI designs. Take a [demand-driven schema design approach](/technotes/TN0027-demand-oriented-schema-design/) and write your prefered query from the client's perspective. The demand-driven concept can apply to any client, but for UI applications **we want to have a direct line from API response to items on the screen**.

If you find yourself describing steps to go from API to views those are warning signs that you have to duplicate that logic across clients.

### Reduce logic in existing client code

For existing code, identify any locations with conditional or switches as logic. This may be new to some as we traditionally think of logic as business rules in our backend. However, if you have ever had to update these areas of the code for a new feature or your product manager has asked you to tweak how the feature works then this can be considered logic. If you had to change things in one client, you probbably had to change them in others.

### Return product info, not domain data

Any other places that accept your API response and involve transforms, concatinations, or helper functions are additional warning signs for logic. Instead of enums, booleans, or numbers, you most likely only need to use strings. With using only strings the server can handle all concerns on the backend and return formatted and localized text that is ready to display. The one area of "logic" we can use is nullable strings (`String` vs `String!`). With server controlled nullability, our client code can check the API response: if the field is present it renders that component, if it is missing it does nothing.

### Use a design system

Now that our API is being used the same by all clients, we need a shared language that client apps use to render their views. This is exactly what a design system is for. With a shared design, we can plan a change once to the API and know that all clients who are using that version of the design system can consume it.

### Define your capabilities with GraphQL types

Once we have a design system we have to implement it in code. Our GraphQL schema is the place where we can codify the capabilities of our API and using GraphQL queries, clients can still opt-in to only selecting the features or types that they support

### Adopt SDUI incrementally

Following all the guiding principles, teams can go beyond what is needed and over complicate their apps by making everything server-driven. If you still have static parts of the app or things that do not need updating, keep those as-is before you require clients to change to adopt a new pattern. SDUI will speed up feature release time in the future, but the initial adoption still requires work.

## Schema Design

Take for example this mock ecommerce schema which allows us to display a list of featured products:

```graphql
type Product @key(fields: "id") {
  id: ID!
  name: String
  formattedPrice: String
  # other product fields...
}

type ProductsCarousel {
  products: [Product]
  count: Int
}

type ProductsList {
  products: [Product]
  count: Int
}

type ProductsError {
  message: String!
}

union FeaturedProductsResponse = ProductsList | ProductsCarousel | ProductsError

type Query {
  featuredProducts: FeaturedProductsResponse
}
```

While querying `Query.featuredProducts` the client can now render multiple specific experiences depending on the query result. We can use the returned `__typename` value to determine if a collection of products should be rendered, or show the user an error message.

```graphql
fragment productFields on Product {
  id
  name
  formattedPrice
}

query FeaturedProductsCollection {
  featuredProducts {
    __typename
    ... on ProductsList {
      products {
        ...productFields
      }
    }
    ... on ProductsCarousel {
      products {
        ...productFields
      }
    }
    ... on ProductsError {
      message
    }
  }
}
```
